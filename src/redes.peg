{

	function indent (t) {
    	return "\n  "+t.replace(/\n/g,'\n  ')+"\n";
    }

	function str (str) { return JSON.stringify(String(str)) ;}
    const ops = {
      'token':  ({token})    =>  `$_token(${str(token)})`,
      'itoken': ({token})    =>  `$_itoken(${str(token)})`,
      'match':  ({char})     =>  `$_char(/[${char}]/)`,
      'imatch': ({char})     =>  `$_char(/[${char}]/i)`,
      'dot':    ()           =>  `$_dot()`,
      'dollar': ({child})    =>  `$_dollar(${proc(child)})`,
      'star':   ({child})    =>  `$_star(${proc(child)})`,
      'plus':   ({child})    =>  `$_plus(${proc(child)})`,
      'maybe':  ({child})    =>  `$_maybe(${proc(child)})`,
      'bang':   ({child})    =>  `$_bang(${proc(child)})`,
      'amp':    ({child})    =>  `$_amp(${proc(child)})`,
      'rule':   ({rule})     =>  {
        if (!ruleNames.includes(rule)) error( 'Unknown rule '+rule);
      	return `(comp_${rule}||rule_${rule})`
       },
      'or':     ({children}) =>  `$_or([${children.map(proc).join(',\n')}])`,
      'seq':    ({children,action}) => {
        var names = [];
        var args = children.map(({name,child})=>{
          if (!name) return `[${proc(child)}]`
          names.push(name);
          return `[${proc(child)},${str(name)}]`;
        })
		if (!action) return `$_seq([${args.join(',\n')}])`;
        var actionArgs = `({${names.join(',')}})`;
        try {
          var fn = new Function(`return(${action})`);
          var actionFn = `${actionArgs}=>(${action})`;
        } catch (err) {
          try {
            var fn = new Function(action);
            var actionFn = `${actionArgs}=>{${action}}`;
          } catch (err) {
            throw err
          }
        }
        return `$_seq([${args.join(', ')}],${actionFn})`;
      },
      'def':   ({name,def}) => {
		return `var comp_${name}; const rule_${name}=(S)=>(comp_${name}||(comp_${name}=${proc(def)}))(S)`
      },
      'grammar': ({intro,defs}) => {
      	ruleNames = defs.map(def=>def.name);
        var rules = defs.map(proc);
        return `${intro}\n\n${rules.join('\n')}\nconst $_start=rule_${defs[0].name}`;
      }
    };
    var ruleNames;
    function proc(node) {
    	if (Array.isArray(node)) return node.map(n=>proc(n));
        if (!node || !node.$) return node;
    	if (ops[node.$]) {
        	return ops[node.$](node);
        } else {
          var ret = {$:node.$};
          for (var i in node) {
            if (i=='$') continue;
            ret[i]=proc(node[i]);
          }
          return ret;
        }
    }
}

proc
= grammar:grammar _ !.{
  return proc(grammar);
}


grammar
= intro:action? _ defs:def+ {
  return {$:'grammar',intro,defs};
}
 
def
= _ name:ident _ "=" _ def:or eol {
  return {$:'def',name,def}
}

or 
= head: seq tail: (
  _ [|/] _ seq:seq { return seq }
)* { 
	if(!tail.length) return head;
    return {$:'or',children:[head].concat(tail)};
}

seq  
= children:(
   head: chunk tail: ( __ chunk:chunk { return chunk } )+ {return [head].concat(tail)} 
/ chunk:named_chunk { return [chunk] }
)
   action:action? {
   return {$:'seq',children,action}
}
/ piece:piece action:action {
  return {$:'seq',children:[{name:'match',child:piece}],action};
}
/ piece 

action = _ block:block { return block }

chunk
= named_chunk
/ anon_chunk

named_chunk
= name:ident _ ":" _ child:piece {
	return {name,child}
}

anon_chunk =
child: piece {
	return {child}
}

piece
= "!" child:bit {
    return {$:'bang',child}
}
/ "&" child:bit {
    return {$:'amp',child}
}
/ "$" child:bit {
    return {$:'dollar',child}
}
/ bit 
bit
= star
/ plus
/ maybe
/ atom

rule
=  !def rule:ident {
	return {$:'rule',rule}; 
}

maybe
= child:atom _ "?" {
    return {$:'maybe',child}
}

star
= child:atom _ "*" {
    return {$:'star',child}
}

plus
= child:atom _ "+" {
    return {$:'plus',child}
}

atom
= token
/ match
/ dot
/ rule
/ "(" _ or:or _ ")" { return or }

token
= token:( token1 / token2 ) i:"i"? {
  try {
    let str = JSON.parse(`"${token}"`)
    if (i) return {$:'itoken',token:str};
    return {$:'token',token:str};
  } catch (err) {
    error(err);
  }
}

token1 
= [''] token:ctoken1+ [''] { return token.join('') }

ctoken1
= "\\'" { return "'" }
/ '"' { return '\\"' }
/ [^']

token2 
= [""] token:ctoken2+ [""] { return token.join('') }

ctoken2
= '\\"' 
/ [^"]


match
= "[" char:$(("\\]"/[^\]])+) "]" i:"i"? {
  if (i) return {$:'imatch',char};
  return {$:'match',char}
}

dot
= dot:"." { 
  return {$:'dot'}
}

block 
= "{" _ chunks:block_chunk* _ "}" { return chunks.join('') }

block_chunk
= $([^'"{}`]+)
/ $("'" ("\\'"/[^\n'])* "'")
/ $('"' ('\\"'/[^\n"])* '"')
/ template
/ $(block)

template
= $('`' template_chunk* '`')

template_chunk
= $('\\$')
/ $('$' block)
/ $([^$`]+)
/ "$" !"{"

ident
= $([a-z_]i [a-z0-9]i*)+

_ = [ \n\t\r]*
__ = [ \n\t\r]+

eol = (_ "\n") + / _ !"."
