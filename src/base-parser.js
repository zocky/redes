/*
  baseParser: 

  Parsers are built from the source of S function and additional functions generated by
  the grammar parser.
*/

'use strict';


module.exports = function redes () {
  const MAX_OPS = 100000;
  const MAX_DEPTH = 1000;
  function $_parse(text="") {
    var state = {
      text: text,
      pos: 0,
    }
    var res = $_start(state);
    if (state.pos!==text.length) {
      var lines = state.text.slice(0,state.pos).split(/\n/);
      var line = lines.length;
      var col = lines.pop().length+1;
      throw new Error(`Syntax error at [${line}:${col}]: ${text.substr(text,20)}`)
    }
    return res[0];
  }
  
  const $_literal = (chars="") => {
  	return (S)=> (
        S.text.substr(S.pos,chars.length) === chars
        && (S.pos+=chars.length,[chars])
    )
  }
  const $_iliteral= (chars)=> {
  	return (S)=>{
      const tchars = S.text.substr(S.pos,chars.length)
      if(tchars.toLowerCase() === chars) {
        S.pos+=chars.length;
        return ([tchars]);
      }
    }
  }
  const $_char=(re)=> {
  	return (S)=>{ 
      const char = S.text.charAt(S.pos);
      return re.test(char) && (S.pos++,[char]);
    }
  }
  const $_dot=() =>{
  	return (S) => S.pos < S.text.length && [S.text.charAt(S.pos++)];
  }
  const $_seq=(args,action) =>{
  	return (S)=>{ 
      const pos=S.pos;
      const ret = {};
      for (const [fn,name] of args) {
        switch(name) {
        case '!':
          const bpos = S.pos;
          const bres = fn(S,ret)
          if (bres) return (S.pos=pos,false);  
          S.pos = lpos; 
          break;
        case "&": 
          const apos = S.pos;
          const ares = fn(S,ret)
          if (!ares) return (S.pos=pos,false);  
          S.pos = apos; 
        default:
          const res = fn(S)
          if(!res) return (S.pos=pos,false);
          if(name) ret[name] = res[0];
        }
      }
      return action ? [action(S,ret)] : [ret];
    }
  }
  const $_or=(args)=> {
  	return (S)=>{ 
      for (const arg of args) {
      	const res = arg(S);
        if (res) return (res);
      }
      return false
    }
  }
  const $_dollar=(arg)=> {
  	return (S)=>{
    	const pos = S.pos;
      return arg(S) && [S.text.slice(pos,S.pos)];
    }
  }
  const $_amp=(arg)=> {
  	return (S)=>{
    	const pos = S.pos, res = arg(S);
      S.pos = pos;
      return res;
    }
  }
  const $_bang=(arg)=> {
  	return (S)=>{
    	const pos=S.pos, res = arg(S);
      S.pos = pos;
      return res ? false : [];
    }
  }
  const $_plus=(arg) =>{
  	return (S)=>{
      const ret=[]; var res;
      while(res=arg(S)) ret.push(res[0]);
      return ret.length && [ret];
    }   
  }
  const $_maybe=(arg) =>{
  	return (S)=>{
      return arg(S) || [];
    }   
  }
  const $_star=(arg)=> {
    return (S)=>{
      var ret=[], res;
      while(res=arg(S)) ret.push(res[0]);
      return [ret];
    }   
  }
  
  /*###SPLIT###*/

  /*###SPLIT###*/

  return {parse:$_parse}
}
