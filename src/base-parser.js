/*
  baseParser: 

  Parsers are built from the source of S function and additional functions generated by
  the grammar parser.
*/

'use strict';


module.exports = function Redes () {
  const MAX_OPS = 100000;
  const MAX_DEPTH = 1000;
  const Parser = {parse:$_parse}

  function $_parse(text="",{ast=false,loc=false}={}) {
    var _pos = 0;
    const _location={line:1,col:1};
    const $state = { 
      get $loc() {
        if (_pos!==state.pos) {
          const lines = state.text.slice(0,state.pos).split(/\n/);
          _location.line = lines.length+1;
          _location.column = lines[lines.length-1].length+1;
          _pos=state.pos;
        }
        return _location;
      },
      get $line() {
        return $state.$location.line;
      },
      get $col() {
        return $state.$location.col;
      }
    }
    const state = {
      ast,
      loc,
      text,
      pos: 0,
      $: $state
    }
    var res = $_start(state);
    if (state.pos!==text.length) {
      throw new Error(`Syntax error at [${$state.$line}:${$state.$col}]: ${text.substr(text,20)}`)
    }
    return res[0];
  }
  

  const $_literal = (chars="") => {
  	return (S)=> (
        S.text.substr(S.pos,chars.length) === chars
        && (S.pos+=chars.length,[chars])
    )
  }
  const $_iliteral= (chars)=> {
  	return (S)=>{
      const tchars = S.text.substr(S.pos,chars.length)
      if(tchars.toLowerCase() === chars) {
        S.pos+=chars.length;
        return ([tchars]);
      }
    }
  }
  const $_char=(re)=> {
  	return (S)=>{ 
      const char = S.text.charAt(S.pos);
      return re.test(char) && (S.pos++,[char]);
    }
  }
  const $_dot=() =>{
  	return (S) => S.pos < S.text.length && [S.text.charAt(S.pos++)];
  }
  const $_seq=(args,action) =>{
  	return (S)=>{ 
      const pos=S.pos;
      const ret = {};
      for (const [fn,name] of args) {
        switch(name) {
        case '!':
          const bpos = S.pos;
          const bres = fn(S,ret)
          if (bres) return (S.pos=pos,false);  
          S.pos = lpos; 
          break;
        case "&": 
          const apos = S.pos;
          const ares = fn(S,ret)
          if (!ares) return (S.pos=pos,false);  
          S.pos = apos; 
        default:
          const res = fn(S)
          if(!res) return (S.pos=pos,false);
          if(name) ret[name] = res[0];
        }
      }
      if (!S.ast && action) return [action(S.$,ret)];
      if(S.loc) ret.$loc = S.$.$loc;
      return [ret];
    }
  }
  const $_or=(args)=> {
  	return (S)=>{ 
      for (const arg of args) {
      	const res = arg(S);
        if (res) return (res);
      }
      return false
    }
  }
  const $_dollar=(arg)=> {
  	return (S)=>{
    	const pos = S.pos;
      return arg(S) && [S.text.slice(pos,S.pos)];
    }
  }
  const $_amp=(arg)=> {
  	return (S)=>{
    	const pos = S.pos, res = arg(S);
      S.pos = pos;
      return res;
    }
  }
  const $_bang=(arg)=> {
  	return (S)=>{
    	const pos=S.pos, res = arg(S);
      S.pos = pos;
      return res ? false : [];
    }
  }
  const $_plus=(arg) =>{
  	return (S)=>{
      const ret=[]; var res;
      while(res=arg(S)) ret.push(res[0]);
      return ret.length && [ret];
    }   
  }
  const $_maybe=(arg) =>{
  	return (S)=>{
      return arg(S) || [];
    }   
  }
  const $_star=(arg)=> {
    return (S)=>{
      var ret=[], res;
      while(res=arg(S)) ret.push(res[0]);
      return [ret];
    }   
  }
  
  /*###SPLIT###*/

  /*###SPLIT###*/

  return Parser;
}
