/*
  baseParser: 

  Parsers are built from the source of this function and additional functions generated by
  the grammar parser.
*/


module.exports = function redes () {
  const FAIL = ['FAIL'];
  const MAX_OPS = 100000;
  const MAX_DEPTH = 1000;
  return {parse:$_parse}
  function $_parse(text) {
    var state = {
      text: text,
      pos: 0,
      ops: 0,
      stack:[],
      begin() {
        this.stack.push(this.pos);
        if (this.stack.length> MAX_DEPTH)
          throw({message:'too much recursion: MAX_DEPTH='+MAX_DEPTH});
        this.ops++;
        if (this.ops>this.MAX_OPS)
          throw({message:'too many ops: MAX_OPS='+MAX_OPS});
      },
      found(c) {
        this.stack.pop();
        return c;
      },
      fail() {
        this.pos = this.stack.pop();
        return FAIL;
      }
    }
    var res = $_start.apply(state);
    if (state.pos!==text.length) {
      var lines = state.text.slice(0,state.pos).split(/\n/);
      var line = lines.length;
      var col = lines.pop().length;
      console.log('syntax error at line',line,'col',col,text.slice(state.pos,20))
    }
    return res;
  }
  
  function $_token(chars) {
  	return function (){ 
      this.begin();
      if(this.text.substr(this.pos,chars.length) == chars) {
        this.pos+=chars.length;
        return this.found(chars);
      }
      return this.fail()
    }
  }
  function $_char(re) {
  	re = new RegExp(re);
  	return function (){ 
      this.begin();
      if(this.pos>=this.text.length) return this.fail();
      var char = this.text.charAt(this.pos);
      if (!re.test(char)) return this.fail();
      this.pos++;
      return this.found(char);
    }
  }
  function $_any() {
  	return function (){ 
      this.begin();
      if(res.pos>=this.text.length) return this.fail;
      var char = this.text.charAt(this.pos);
      this.pos++;
      return this.found(char);
    }
  }
  function $_seq(args,action) {
  	return function (){ 
      this.begin();
      var ret = {};
      for (var arg of args) {
        if (!Array.isArray(arg)) {
          console.log(arg)
          throw 'not an array'
        }
      	var res = arg[0].apply(this);
        if(res==FAIL) return this.fail();
        if(arg[1]) ret[arg[1]] = res;
      }
      if (action) return this.found(action.call(this,ret,this))
      return this.found(ret)
    }
  }
  function $_or(...args) {
  	return function (){ 
      this.begin();
      for (var arg of args) {
      	var res = arg.apply(this);
        if(res!==FAIL) return this.found(res);
      }
      return this.fail()
    }
  }
  function $_dollar(arg) {
  	return function (){
    	this.begin();
      let start = this.pos;
      if (arg.apply(this)===FAIL) return this.fail();
      return this.found(this.text.slice(start,this.pos));
    }
  }
  function $_amp(arg) {
  	return function (){
    	this.begin();
      let start = this.pos;
      var res = arg.apply(this);
      if (res===FAIL) return this.fail();
      this.pos = start;
      return this.found(res);
    }
  }
  function $_bang(arg) {
  	return function (){
    	this.begin();
      let start = this.pos;
      var res = arg.apply(this);
      if (res!==FAIL) return this.fail();
      this.pos = start;
      return this.found();
    }
  }
  function $_plus(arg) {
  	return function (){
      this.begin();
      var ret = [];
      do {
        var res = arg.apply(this);
        if (res===FAIL) break;
        ret.push(res);
      } while (true)
      if (!ret.length) return this.fail();
      return this.found(ret);
    }   
  }
  function $_maybe(arg) {
  	return function (){
      this.begin();
      var ret = [];
      var res = arg.apply(this);
      if (res===FAIL) return this.found();
      return this.found(res);
    }   
  }
  function $_star(arg) {
    return function (){
      this.begin();
      var ret = [];
      do {
        var res = arg.apply(this);
        if (res===FAIL) break;
        ret.push(res);
      } while (true)
      return this.found(ret);
    }   
  }
}
